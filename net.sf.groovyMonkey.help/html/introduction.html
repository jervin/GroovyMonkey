<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Groovy Monkey</title>
</head>
<body>
<h2>Introduction</h2>

<p>
Why does this project Groovy Monkey exist?  What need could it possibly meet 
and why should I consider it?  Since I am the author of Groovy Monkey I am bit biased
and could probably tell you how it can create world peace, solve hunger and solve
everything else that ills the world.  I can couch this outrageous statement in enigmatic
abstract language that is intended to make you feel foolish and raise my standing in
your eyes.  Since you can't understand what I am saying, but apparently it can do so
much, then you must try the tool, right?  
</p>

<p>
Well I am not going to do that. This is an Open Source tool that is available for free 
to anybody. So I am not making any money off of this and therefore will dispense with
that kind of introduction. I will try and write the kind of introduction that I 
wish I would get more often when looking at software packages, the story.  What do I
mean by the story?  Well every software ( particularly open source ) started off as an
idea or namely a problem that the developer was trying to address.  The developer
then goes off and bangs out a tool that helps him/her solve their problem.  The developer
being a smart person begins to think that their solution might be useful to others
and then that usually is the start of the project.  As they continue developing the
project, there is a light that goes off and they realize that hey I can make this 
some sort of abstract framework that is useful for just about everything ( read: 
in reality almost nothing ) and announce their product to the world.  When the 
developer gets to this point is when they usually write the documentation and 
leave confusion in their wake.  The point is that I find it far more helpful in
potentially finding the use of a product by hearing that back story, what problem was
targetted and how they resolved it.  This is what I am going to try and do next.
</p>

<h3>Eclipse is extensibly complex</h3>

<p>
Anyone who has started out trying to browse around the Eclipse API thinks the title of
this section is a serious understatement.  Do not get me wrong, I love Eclipse.  I think
that the modular architecture, with lazy loading and component descriptors is <b>the</b> 
way to go.  I think that there are many good lessons to be learned about how to write 
good decoupled code by studying the Eclipse Platform API and code.  I am finally even
sold on the migration to the OSGi framework underneath the sheets.  I think that the
Eclipse team has done a good job of "eating their own poo" and providing the ability
to self-host.  Still the API and code can be a <b>bit</b> daunting and the javadocs
can be a bit <b>ahem..</b> terse. So there is a demonstratable need to be able to 
write some test code to exercise those APIs and answer the inevitable questions that 
arise while writing plugins.  The other main area of interest is the ability to automate
some commands in Eclipse or be able to write some form of macro.  I am going to list the 
available "Eclipse" ways of tackling the above problems and highlight the limitations 
of those approaches.
</p>

<h4>Write a workspace plugin and use self hosting</h4>

<p>
The last software development project I was working on, we used Eclipse exclusively.  
As time went by, it became apparent to me that we could use some tools to help us
in our software development.  As I worked on some of these tools, I stumbled upon the
ability to self host Eclipse to write some tool plugins.  I would start a parent Eclipse 
instance with a workspace that contained my tool plugin I was working on and then 
start a runtime Eclipse instance in debug mode that had the workspace of our overall 
software project.  This actually works pretty well if you have a machine with good 
memory resources ( my machine had 2GB of RAM ), but it gets hampered in that it 
has to rely on Java hotswapping, which is far too limited.  Even though the setup
I had allowed self hosting to work pretty well, the inability to run your workspace
plugin against your current workspace and Eclipse instance can be a significant
limitation.  Since the runtime Eclipse instance relies on Java hot swapping, if 
I did something so simple as change a method name in a class of my tool plugin, 
I would have to restart my runtime Eclipse instance.  Even with a nice workstation, 
this would get very annoying.  Of course, this solution is not a good one if you 
don't have a nice workstation to play on.  
</p>

<p>
Still the use of self hosting did have one major advantage, you did not have to mess with
trying to export plugins to an update site and have Eclipse update your plugin in your
current workspace.  In other words, no feature or feature export or having to screw with
the version everytime I wanted to try something new.  Why don't the Eclipse Platform
people fix features and update sites?
</p>

<h4>Scratch Pad</h4>

<p>
I remember hearing about this tool sometime back and then I promptly forgot about it.  
Before I dived into Groovy Monkey I went back and evaluated it.  I think it is a tool
with some potential, but I had a hard time trying to figure out how to do even a simple
example ( there were way to many mouse clicks and the like ).  Even once I got an 
example to work, it still does not run within your current workspace instance, it still
spawns a seperate JVM to evaluate your code and you could not use your current workspace
and its projects to test against the code in the scratchpad.
</p>

<h4>Eclipse Shell</h4>

<p>
</p>

<h4>Eclipse Monkey</h4>

<p>
</p>

<h2>Groovy Monkey is born</h2>

<p>
</p>

<h2>Groovy Monkey features</h2>

<p>
</p>

<h2>Conclusion</h2>

<p>
</p>

</body>
</html>